Домашние задания

### Домашнее задание 1

  1. Разработайте класс `Grep`, осуществляющий поиск подстрок к файлах. 
  2. Класс `Grep` должен поддерживать следующую функциональность: 
    1. При запуске 
    
    java Grep строка1 строка2 ... строкаN

ищет в файлах указанные `N` подстрок.

    2. При запуске 
    
    java Grep -

список искомых подстрок читается со стандартного ввода.

    3. Поиск строк осуществляется во всех файлах текущей директории и всех поддиректориях (рекурсивно). Порядок, в котором обрабатываются файлы не важен. 
    4. Если строка файла содержит хотя бы одну из искомых подстрок, то на стандартный вывод должно быть выдано сообщение в формате: 
    
    относительный-путь-к-файлу: строка-файла

Например, если ищется подстрока `hello` и файл `qqq/HelloWorld.java` содержит
строку

    
    System.out.println("hello, world!")

, то вывод должен содержать строку

    
    qqq/HelloWorld.java: System.out.println("hello, world!")

    5. Каждый файл читается не более одного раза. 
    6. Размеры файлов и строк в них могут превышать размер оперативной памяти. 
    7. Консольный ввод-вывод и поиск осуществляется в кодировке UTF-8. 
    8. Осущетсвляется поиск не более чем 1000 подстрок длиной до 1000 символов каждая. 
  3. Усложненная версия: 
    1. Поиск строк должен осуществляться в кодировках UTF-8, KOI8-R, CP1251, CP866. 
    2. Должен поддерживаться поиск в бинарных файлах и файлах, содержащих фрагменты в разных кодировках. 
    3. Каждый файл читается не более одного раза. 
  4. При выполнении задания следует обратить внимание на: 
    * Дизайн и обработку исключений, диагностику ошибок. 
    * Программа должна корректно завершаться даже в случае ошибки. 
    * Корректная работа с вводом-выводом. 
    * Отсутствие утечки ресурсов. 
    * Отсутствие дублирования кода. 
  5. Требования к оформлению задания. 
    * Проверяется исходный код задания. 
    * Весь код должен находиться в пакете `ru.ifmo.ctddev.фамилия.task1`. 

### Домашнее задание 2

  1. Разработайте класс `ArraySet`, реализующие неизменяемое упорядоченное множество. 
    * Класс `ArraySet` должен реализовывать интерфейс `SortedSet` (упрощенная версия) или `NavigableSet` (усложненная версия). 
    * Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью. 
  2. При выполнении задания следует обратить внимание на: 
    * Применение стандартных коллекций. 
    * Избавления от boilerplate кода. 

### Домашнее задание 3

  1. Реализуйте класс `Implementor`, который будет генерировать реализации классов и интерфейсов. 
    * Аргументы командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию. 
    * В результате работы должен быть сгенерирован java-код класса с суффиксом `Impl`, расширяющий (реализующий) указанный класс (интерфейс). 
    * Сгенерированный класс должен компилироваться без ошибок. 
    * Сгенерированный класс не должен быть абстрактным. 
    * Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по-умолчанию. 
  2. В задании выделяются три уровня сложности: 
    * _Простой_ -- `Implementor` должен уметь реализовывать только интерфейсы (но не классы). Поддержка Generics не требуется. 
    * _Сложный_ -- `Implementor` должен уметь реализовывать и классы и интерфейсы. Поддержка Generics не требуется. 
    * _Бонусный_ -- `Implementor` должен уметь реализовывать и Generic-классы и интерфейсы. Сгенерированный код должен иметь корректные параметры типов. 

### Домашнее задание 4

  1. Создайте `.jar`-файл, содержащий скомпилированный `Implementor` и сопутствующие классы. 
    * Созданный `.jar`-файл должен запускаться командой `java -jar`. 
    * Запускаемый `.jar`-файл должен принимать те же аргументы командной строки, что и класс `Implementor`. 
  2. Модифицируйте `Implemetor` так, что бы при запуске с аргументами `-jar имя-класса файл.jar` он генерировал `.jar`-файл с реализацией соответствующего класса (интерфейса). 
  3. Для проверки, кроме исходного кода так же должны быть предъявлены: 
    * скрипт для создания запускаемого `.jar`-файла, в том числе, исходный код манифеста; 
    * запускаемый `.jar`-файл. 

### Домашнее задание 5

  1. Документируйте класс `Implementor` и сопутствующие классы с применением Javadoc. 
    * Должны быть документированы все классы и все члены классов, в том числе закрытые (`private`). 
    * Документация должна генерироваться без предупреждений. 
    * Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки. 
  2. Для проверки, кроме исходного кода так же должны быть предъявлены: 
    * скрипт для генерации документации; 
    * сгенерированная документация. 

### Домашнее задание 6

  1. Реализуйте класс `Client`, который будет генерировать задачи и исполнять их с применением `TaskRunner`. 
    * Клиент в бесконечном цикле должен генерировать задание, исполнять его при помощи `TaskRunner`, печатать результат исполнения на экран. 
    * Разные клиенты должны иметь возможность использовать разные `TaskRunner`'ы. 
    * Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один `TaskRunner`. 
  2. Реализуйте класс `TaskRunnerImpl`, реализующий интерфейс `TaskRunner` и исполняющий задачи в заданном числе потоков. 
    * К одному `TaskRunnerImpl` могут одновременно обращаться несколько клиентов. 
    * Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления. 
    * В реализации не должно быть активных ожиданий. 
  3. Общие интерфейсы: 
    * Задача: 
    
    
    public interface Task<X, Y> {
        X run(Y value);
    }
                                    

    * Исполнитель задач: 
    
    
    public interface TaskRunner {
        <X, Y> X run(Task<X, Y>, Y value);
    }
                                    

### Домашнее задание 7

  1. Реализуйте цепочку генерации и исполнения заданий. 
    * Класс `Producer` генерирует задания и передает их на исполнение. 
    * Класс `Worker` исполняет задания и передает их на публикацию. 
    * Класс `Publisher` публикует результаты исполнения заданий. 
  2. Одновременно должны работать по 10 `Producer`'ов, `Worker`'ов и `Publisher`'ов. 
  3. Если `Worker`'ы или `Publisher`'ы не успевают обрабатывать задания, то генерация заданий должна приостанавливаться. 
  4. Пример задания для исполнения выбрать самостоятельно. 
